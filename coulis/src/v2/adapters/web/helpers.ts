import type { StyleProperties } from "../../core/entities/style";
import { SHORTHAND_PROPERTIES, UNITLESS_PROPERTIES } from "./constants";

/**
 * Escape invalid CSS characters to generate usable property names.
 * @param name - The property name to escape with potentially some unsafe characters.
 * @returns The escaped property name.
 * @see https://mathiasbynens.be/notes/css-escapes
 * @example
 * const safeCssVariable = escape("--spacings-1.5"); // Will generate `--spacings-1\5`
 */
export const escape = (name: string) => {
	return name.replaceAll(/[!"#$%&'()*+,./:;<=>?@[\]^`{|}~]/g, "\\");
};

export const createClassName = (input: string) => {
	// hash content based with FNV-1a algorithm:
	const FNVOffsetBasis = 2166136261;
	const FNVPrime = 16777619;
	let hashedValue = FNVOffsetBasis;

	for (let index = 0; index < input.length; index++) {
		const characterUnicodeValue = input.codePointAt(index);

		if (!characterUnicodeValue) continue;

		hashedValue ^= characterUnicodeValue;
		hashedValue *= FNVPrime;
	}

	/*
	 * We convert hashed value to 32-bit unsigned integer
	 * via logical unsigned shift operator >>>
	 */
	const uHash = hashedValue >>> 0;

	/*
	 * A coulis className is generated by prefixing with "c"
	 * and converting generated hash to hexadecimal
	 */
	return `c${Number(uHash).toString(16)}`;
};

export const createDeclaration = ({
	name,
	value,
}: {
	name: keyof StyleProperties;
	value: StyleProperties[keyof StyleProperties];
}) => {
	// From JS camelCase to CSS kebeb-case
	const transformedPropertyName = name.replaceAll(
		/([A-Z])/g,
		(matched) => `-${matched.toLowerCase()}`,
	);

	// Format value to follow CSS specs (unitless number)
	const transformedPropertyValue =
		typeof value === "string" || UNITLESS_PROPERTIES[name]
			? String(value)
			: `${String(value)}px`;

	return `${transformedPropertyName}:${transformedPropertyValue};`;
};

export const createDeclarations = <Properties extends StyleProperties>(
	properties: Properties,
) => {
	let declarationBlock = "";
	const propertyNames = Object.keys(properties) as (keyof StyleProperties)[];

	for (const propertyName of propertyNames) {
		const value = properties[propertyName];

		if (value) {
			declarationBlock += createDeclaration({
				name: propertyName,
				value,
			});
		}
	}

	return declarationBlock;
};

export const isShorthandProperty = (name: keyof StyleProperties) => {
	return Boolean(SHORTHAND_PROPERTIES[name]);
};

/**
 * Compose multiple class names together.
 * @param classNames - A collection of string-based class names.
 * @returns The composed class names.
 * @example
 * const classNames = compose(styles({ backgroundColor: "red" }), styles({ color: "red" }));
 * document.getElementById("my-element-id").className = classNames;
 */
export const compose = (...classNames: string[]) => {
	return classNames.join(" ");
};

export const isNumber = (value: unknown): value is number => {
	return typeof value === "number" || !Number.isNaN(Number(value));
};

export const isObject = (value: unknown): value is Record<string, unknown> => {
	return typeof value === "object" && value !== null && !Array.isArray(value);
};

export const minify = (value: string) => {
	return value.replaceAll(/\s{2,}|\s+(?={)|\r?\n/gm, "");
};

export const createError = (parameters: {
	api: string;
	cause: string;
	solution: string;
}) => {
	return `\`${parameters.api}\`: ${parameters.cause}. ${parameters.solution}.`;
};
